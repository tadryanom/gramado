/*
 * File: mm/mm.h  
 *
 * Descrição:
 *     Header para o Memory Manager. Gerenciamento de memória.
 *
 * Ordem de importância do gerenciamento de memória:
 *     > Endereços dos page directories.
 *     > Endereços das pagetables. 
 *     > 
 *
 * Obs:
 *     Em executive, temos áreas de memórias reservadas para o sistema. 
 * Privilégios de executivo.
 *
 * @todo: 
 *     Criar blocos livres e alocados. 
 *     1 - Linked List of free blocks.
 *     2 - Procurar por blocos livres de tamanho suficiente para a alocação. 
 *     3 - Memory Pool, pre aloca blocos de tamanho fixo, ex: 4096.
 *     Estrutura e manipulação de 'page frames'.
 *     ...
 * @todo: + Mapping kernel mode memory into user address space.
 *          Dentro do espaço disponível para o usuário, ele poderá
 *          ler um conteúdo colocado pelo kernel para ele.
 *          Isso é uma área de transferência. 
 *
 * Histórico:
 *     Versão 1.0, 2015 - Esse arquivo foi criado por Fred Nora.
 *     Versão 1.0, 2016 - Revisão.
 *     ...
 */

/*
    Sobre 'pages' e 'page frames':
	============================
	pages: 
	    São blocos de memória virtual. 
		?? São blocos de disco equivalentes aos blocos de memória física.??
		
    pageframes: 
	    São blocos na memória física equivalentes aos blocos do disco.
 */ 
 
 
/*
    Memory map:
    (process page directory).	
	
	" Cada processo tem seu diretório e uma configuração de 4GB de memória 
virtual. Essa é a memória virtual para processos criados, uma padronização que
será respeitada na hora de criar o diretório de páginas de um processo ".	
	" Note que o início da memória virtual está disponível para drivers ou 
bibliotecas de link dinâmico ".   
	" Todo processo começará em 0x00400000vir e terá o entry point em 
0x00401000virt ". "Bibliotecas de ligação dinâmica, começarão em 0x0vir
e não sei se essas bibliotecas tem entry point"

	//...

 @todo: 	
     " O ideal é que um processo tenha disponível pra si toda a área baixa de 
memória virtual, até o início da área do kernel".
     "A divisão da memória virtual do processo entre a parte que pertence ao 
processo e a parte que pertence ao kernel tem seguido o seguinte padrão:
(1) meio à meio, onde o processo fica com os 2GB mais baixos e o kernel fica 
com os 2GB superiores, ou (2) O processo fica com os 3GB mais baixos e o
kernel fica com o 1GB superior."	 


    Mapeamento padrão de memória virtual para todos os processos do sistema:
    =======================================================================	


             +------------------------------------+
    FFFFFFFF |             FIM                    |
             +------------------------------------+ Tem dispositivos aqui em cima.
             +------------------------------------+
             +------------------------------------+ 
             +------------------------------------+
             |           Kernel land              | @todo: 
             |                                    | Mudar de lugar. 
             |                                    | Seder espaço para LFB, que precisa ser grande.
    C0800000 |           BackBuffer               | 
             +------------------------------------+	
             |           Kernel land              |	 Memória da placa de vídeo.
             |             (4MB)                  |  SHARED_MEMORY (0xC0800000 -0x100)
             |             ...                    |  Ampliar (TER O TAMANHO DA MEMÓRIA DA PLACA DE VÍDEO) 
    C0400000 |          FrontBuffer(LFB)          |  Obs: Tamanho da soma das áreas dos monitores, no mínimo.
             +------------------------------------+
             +====================================+
             |           Kernel land              |
             |                                    | 
             |  Stack = 0xC02F7FF0 ~ 0xC02FFFF0   | Total 32KB. 
             |  Heap  = 0xC0100000 ~ 0xC02F7FF0   |	Total 2015 KB.
             |                                    | 
             |  Kernel Entry point = 0xC0001000   | Entry point do kernel.
             |  Kernel Base = 0xC0000000          |	Início da imagem do 
             |                                    |	processo kernel. 
    C0000000 |        ( Kernel Mode access )      | 
             +------------------------------------+
             |           User Land                |
             +------------------------------------+
             +------------------------------------+ 
             +------------------------------------+
             +------------------------------------+  
             |                                    |
             |                                    | @todo  Início da pilha em user mode do proesso.
             |                                    | @todo: Início do heap em user mode do processo.
             |                                    | ### Por enquando cada processo tem sua própria
             |                                    |     pilha e heap no fim da imagem do processo. 
             |                                    | 
             |                                    |
             | 00401000 = Process entry point     | Entrypoint da imagem.
             | 00400000 = Process image base      | Onde se carrega uma imagem de processo.
             |       User Mode access             |  
             |------------------------------------|
             |                                    | #importante
             |                                    | Podemos usar essa área em kernel mode para memória compartilhada.
             |                                    | Os primeiros 4MB são acessados pelo kernel.
             |           0 ~ 0x004FFFFF           | Os processos estão herdando esse mapeamento do kernel. 
    00000000 |         kernel Mode access         | 
             +====================================+
 

    ***



   mm - kernel process



*********************************   
 Memória linear para o processo kernel:

 Kernel Base        = 0xC0000000
 Kernel Entry point = 0xC0001000
 Stack = 0xC02F7FF0 ~ 0xC02FFFF0   | Total 32KB. 
 Heap  = 0xC0100000 ~ 0xC02F7FF0   | Total 2015 KB.


*********************************
 Memória física para o processo kernel: 

 Kernel Base        = 0x00100000
 Kernel Entry point = 0x00101000 
 Heap               =      
 Stack              =  
 
	@todo: 
	    O layout da memória virtual está em fase de desenvolvimento.	   
	    Criar um layout dos endereços físicos principais usados pelo sistema.
*/ 
 










//#define x86_copy_page(from,to) \
//__asm__("cld ; rep ; movsl"::"S" (from),"D" (to),"c" (1024):"cx","di","si")


//#define PAGE_SIZE 4096

#define clear_page(page)    memset((page), 0, PAGE_SIZE)
#define copy_page(to,from)  memcpy((to), (from), PAGE_SIZE) 


/*
static inline void clear_page(void *page)
{
	memset(page, 0, PAGE_SIZE);
}
*/

/*
static inline void copy_page(void *to, void *from)
{
	memcpy(to, from, PAGE_SIZE);
}
*/
 
 //
 // **  ENDEREÇOS DOS PRINCIPAIS PAGE DIRECTORIES **
 //
 
 
// 
// Directory:
// ========== 
//     Endereço físico de alguns diretórios.
//     Esses diretórios são dos utilitários principais.
//     Não tem problema se esses diretórios ficarem isolados.
//     Serão colocados em cr3.
//


//aqui seria um lugar segura para os diretórios desses processos 
//do ambiente Gramado Core.
//para os outros ambientes podemos concatenar os diretórios em 
//outro lugar de fácil acesso.
//Obs: #bugbug No momento estamos usando apenas o diretório do 
//porcesso kernel para tosos os aplicativos do ambiente Gramado Core.

//#define KERNEL_PAGEDIRECTORY  (0x0009C000)  
                      


//Quantas entradas de diretório de páginas cabem em uma página.
#define PDE_PER_PAGE (1024)

//Quantas entradas de tabela de páginas cabem em uma página.
#define PTE_PER_PAGE (1024)



unsigned long gKernelPageDirectoryAddress; 

unsigned long gInitPageDirectoryAddress; 
unsigned long gShellPageDirectoryAddress; 
unsigned long gTaskmanPageDirectoryAddress; 


/* 
 * As configurações de memória foram feitas pelo Boot Loader.
 * (aqui os endereços lógico e físicos são iguais.)
 */


//Quantidade de diretórios que podem ser criados.
//obs: cada processo cria seu próprio diretório. 
//@todo: Criar um array de estruturas alocado.
#define PAGEDIRECTORY_COUNT_MAX 1024  

//Quantidade de page tables criadas...
//cada diretório pode ter um monte de tabelas.
//@todo: Criar um array de estruturas alocado.
#define PAGETABLE_COUNT_MAX 1024 



//
// zones support
//

//memória total em duas partes.
// 


//Zones.
// ** ESSA ESTRUTURA É A RAIZ DE TODA GERÊNCIA DE MEMÓRIA **
typedef struct mm_zones_d mm_zones_t;
struct mm_zones_d
{
    struct system_zone_d *system_zone;  //Essa zona é para o sistema.
    struct window_zone_d *window_zone;  //Essa zona toda é uma user session.
};
mm_zones_t *zones;


//system zone. 
typedef struct system_zone_d system_zone_t;
struct system_zone_d
{
    unsigned long systemzone_start;  //0x00000000. são os 32MB iniciais  
};
system_zone_t *systemzone;


//window zone.  
typedef struct window_zone_d window_zone_t;
struct window_zone_d
{
	unsigned long windowzone_start;
	//Endereço onde começa a user session.
	unsigned long usersession_start;	//ficará dentro de uma área paginada.
    struct usession_d *usersession;    
};
window_zone_t *windowzone;




// variáveis blobais de endereços usados no gerenciamento de zonas de memória.

#define SYSTEMZONE_START 0
#define SYSTEMZONE_END   0x0FFFFFFF 
#define WINDOWZONE_START 0x10000000
//#define WINDOWZONE_END ??

unsigned long systemzoneStart;
unsigned long systemzoneEnd;
unsigned long systemzoneSize;
unsigned long windowzoneStart;
unsigned long windowzoneEnd;    //?? Devemos levar em consideração o calculo do tamanho da memória
unsigned long windowzoneSize;






/*
 * page_directory_d:
 *     Estrutura para o 'page directory' de um processo.
 *
 *     Todo processo tem seu próprio diretório de páginas.
 *     Assim vários processos podem usar o mesmo endereço lógico.
 *     Ex: 0x400000
 *     @todo: Um ponteiro para essa estrutura pode estar no PCB do processo.
 *            usar os processos criados por processos para testar a configuração
 *           de page directory.
 *     Obs: Um diretório tem ponteiros para page tables. as page tables 
 * funcionam como pools de frames.
 */

typedef struct page_directory_d page_directory_t;
struct page_directory_d
{
	
	object_type_t objectType;
	object_class_t objectClass;
	
	//identificadores.
	int id;
	int used;
	int magic;
	
	//Qual processo é o dono do diretório de páginas.
	//talvez seja possivel reaproveitar o diretório.
	struct process_d *process;
	
	//Endereço onde ficará o diretório de páginas.
	//Obs: Para configurar um diretório de páginas talvez
	//tenha que colocar um endereço físico em CR3. Lembre-se
	//que o malloc do kernel base aloca memória no heap do 
	//processo kernel que fica no último giga da memória virtual.
	unsigned long Address;
	
	
	// ?? struct page_directory_entry_d[1024] ??
	
	//@todo: Mais informações sobre o diretório de páginas.
	
	//Próximo diretório, significa próximo processo.
	//significa processos ligados em um job.
    struct page_directory_d *next;  
};
page_directory_t *pagedirectoryKernelProcess;    // KERNEL.
page_directory_t *pagedirectoryIdleProcess;      // IDLE.
page_directory_t *pagedirectoryTaskmanProcess;   // TASKMAN.
page_directory_t *pagedirectoryCurrent;          // Current.
page_directory_t *pagedirectoryShared;           // Shared. 
//...

//
// Lista de diretórios. (Pois cada processo tem um diretório).
//

//Lista de estruturas para diretórios de páginas.
unsigned long pagedirectoryList[PAGEDIRECTORY_COUNT_MAX]; 

//Linked list pode ser uma opção.
//Deve estar em sintonia com o scheduler de threads.
//page_directory_t *pagedirectoryLinkedListHead;



/*
 * page_table_d.
 *     Page table structure.
 *     Obs: Uma page table funciona como um pool de frames.
 *          Também pode ser compartilhada entre processo.(cuidado).
 */

typedef struct page_table_d page_table_t;
struct page_table_d
{
	object_type_t objectType;
	object_class_t objectClass;
	
	int id;
	int used;
	int magic;
	
	//A qual diretório de páginas a page table perrtence.
	//se bem que talvez possamos usar a mesma pagetable
	//em mais de um diretório. será??
	struct page_directory_d *directory;
	
	//Cada pagetable pertence à um processo.
	struct process_d *process;
	
	//Travando uma pagetable inteira,
	//nenhuma de suas páginas poderão se descarregadas
	//para o disco de swap.
	int locked;
	
	// ?? struct page_table_entry_d[1024] ??
	
    //@todo: Mais informações sobre a pagetable.
	struct page_table_d *next;
};
//page_table_t *pagetableCurrent;

page_table_t *pagetableCurrent;
//...

//
// Lista de pagetables.
//

unsigned long pagetableList[PAGETABLE_COUNT_MAX]; 

//Linked List talvez seja uma opção.
//page_table_t *pagetableLinkedListHead;



 
/**
 **  **  SUPER IMPORTANTE  **
 **
 ** Super block.
 ** ESSAS VARIÁVEIS GLOBAIS MARCARÃO O INÍCIO E O FIM 
 ** DA ÁREA DE MEMÓRIA FÍSICA DESTINADA AOS FRAMES DE MEMÓRIA 
 ** FÍSICA QUE SERÃO USADOS PELO GERENCIADOR DE PÁGINAS.
 **
 ** Pertencerão ao banco FDB. (Free Data Base).
 ** 0x10000000 é um bom lugar pra começar os frames ,
 ** na verdade os blocos 4MB, pois cada bloco de 4MB pode ser mapeado 
 ** usando apenas uma pagetable.
 ** 
 ** mmFramesSuperBlockStart = 0x10000000
 ** mmFramesSuperBlockEnd   = 0x1FFFFFFF
 ** 
 ** Esses são endereços físicos.
 ** Obs: Ficarão nesse lugar caso se tenha memória disponível para isso.
 **
 **/
 
// Frames Super Block.
// Variáveis globais parecem ser uma opção melhor de estrutura
// para esse caso. 
// Obs: Temos listas de frames em algum lugar. 
// Criaremos listas aqui para o FSB, que será o nome do gerenciado, 
// para melhorar o controle dessa área.
unsigned long mmFramesSuperBlockStart;      //Endereço onde começa o FSB.
unsigned long mmFramesSuperBlockEnd;        //Endereço onde termina o FSB.
unsigned long mmFramesSuperBlockSize;       //Tamanho do FSB dado em bytes.
unsigned long mmFramesSuperBlockTotal;      //Total de frames.
unsigned long mmFramesSuperBlockTotalFree;  //Total de frames livres. 
unsigned long mmFramesSuperBlockTotalUsed;  //Total de frames e uso. 
//Continua...

// ((0x1FFFFFFF - 0x10000000) / 512)  = QUANTIDADE DE FRAMES NESSA ÁREA.
#define FSB_FRAMES_MAX      (1*1024) //?? @todo: Determinar melhor isso
#define FSB_FREEFRAMES_MAX  (1*1024) //?? @todo: Determinar melhor isso

//## BUGBUG isso tornaria esse array bem grande.


//
// Lista com todos.
//


//Lista de ponteiros para as estruturas de todos os frames do FSB.
unsigned long fsbFrames[FSB_FRAMES_MAX]; 

//
// Lista de livres.
//

//Lista de ponteiros para as estruturas de todos os frames 'LIVRES' do FSB.
unsigned long fsbFreeFrames[FSB_FREEFRAMES_MAX];  
 
 
 
//
// memory:
//


 
 
 
 
//
// MM BLOCK.
// 

//Isso é usdo pelo heap.
#define MMBLOCK_HEADER_SIZE 64 
 


// Quantidade máxima de pageframes.
// @todo: 
// #bugbug. 
// Isso tá errado. 
// Essa é a quantidade de pageframes de apenas uma page table. 
// Isso equiva à apenas um pagepool. enão não poderá ser usado
// em outro lugar enão no contexto de um pagepool.
//

#define PAGE_COUNT_MAX 1024    //??


// Quantidade máxima de framepools.
// Um framepool é uma partição da memória física.
// Cada framepool é composto de 1024 pageframes.
//
// @todo: 
// #bugbug: 
// A quantidade de framepools deve ser equivalente à quantidade 
// de memória física disponível.
// Por isso devemos criar áreas de memória física alocáveis. O que 
// facilita a manutenção de listas de framepools.
//
// Em outras palavra. Temos que concatenar partições de memória física
// pra facilitar. Então chamaremos essa área onde estão as partições de
// área paginável. Pois existem áres de memória que não são pafináveis,
// elas simplesmente foram mapeadas para que alguma parte do sistema use.
//
// @todo: 
// Criar um ponteiro que indique o ínício da área páginável, assim como 
// acontece com o início de um heap.
//
// À principio todo processo poderia ter acesso à apenas uma partição.
// Um framepool é garantido para um processo quando esse processo é criado
// mesmo antes de haver algum mapeamento. Na verdade um processo terá uma lista
// de framepools.
//

//List.(1024 framepools de 4MB dá 4GB).
#define FRAMEPOOL_COUNT_MAX 1024

//#bugbug
//@todo: Aumentar ...
//Contagem de mmblock. 
#define MMBLOCK_COUNT_MAX  (2*4096)
 



//
// ## MEMORY PARTITION ##
//

//Um framepool tem 4MB de tamanho.
#define MEMORY_PARTITION_SIZE (4 * MB)

//
// Obs: Criamos apenas algumas entradas no diretório de páginas
// do kernel, mas algumas dessas entradas serão iguais para todos 
// os processos. Então os diretórios de da páginas dos processos
// serão configurados de forma semelhante.
//

//
// Page frames da imagem do kernel:
// ================================
// Foram alocadas 1024 pageframes para a imagem do kernel.
// Isso equivale a um pageframe pool. Que é igual a 4MB. Pois
// são 1024 page frames de pagínas de 4KB cada.
//

//
// + kernel area = 1024 page frames (4MB)
// + kernel image = 1024 pageframes (4MB)
// + user mode area = 1024 pageframes (4MB)
// + vga = 1024 pageframes (4MB) (Isso transpassa o real tamanho da vga)
// + lfb = (frontbuffer) 1024 pageframes (4MB) (Isso é muito pouco, pois 
//         uma placa de vídeo tem mais memória que isso)
// + backbuffer = 1024 pageframes (4MB) (Isso realmente é pouco, o backbuffer 
//         deve caner uma imagem grande, que será dividade em vários monitores.)
//
//



/*
INVLPG

INVLPG is an instruction available since the i486 that invalidates a single page in the TLB. 
Intel notes that this instruction may be implemented differently on future processes,
 but that this alternate behavior must be explicitly enabled. INVLPG modifies no flags.

NASM example:

     invlpg [0]
Inline assembly for GCC (from Linux kernel source):

static inline void __native_flush_tlb_single(unsigned long addr)
{
   asm volatile("invlpg (%0)" ::"r" (addr) : "memory");
}

*/


/*
typedef enum {
    MM_SYSTEM_SMALL,
    MM_SYSTEM_MEDIUM,
	MM_SYSTEM_BIG,
}SYSTEM_SIZE_T;
*/


/*
 * mmblockCount:
 *     mm block support.
 *     Conta os blocos de memória dentro de um heap.
 *     *dentro do heap usado pelo kernel eu acho ?? 
 */

unsigned long mmblockCount;         
 


/*
 * Kernel Stack suppport.
 */ 

unsigned long kernel_stack_end;        //va
unsigned long kernel_stack_start;      //va
unsigned long kernel_stack_start_pa;   //pa (endereço indicado na TSS).


/*
 * process_memory_info_d:
 *
 *     Estrutura para informações sobre a memória utilizada por um processo.
 * Obs: 
 * O gerenciamento de memória é tarefa do módulo /sm portanto isso não deve 
 * ir para o /microkernel.
 */

typedef struct process_memory_info_d process_memory_info_t;
struct process_memory_info_d
{
	object_type_t objectType;
	object_class_t objectClass;	
	
	struct process_d *process;
	
	//valor em KB. (quantidade de páginas + tamanho da página.)
	
	unsigned long WorkingSet;  //Working Set.
    unsigned long Private;     //Memória não compartilhada. 
    unsigned long Shared;	   //Memória compartilhada.
	//...
	
	
	//unsigned long pageFaults; //Contagem de faltas.
	//Pico de Working Set.
	//??delta de conjunto de trabalho.
	//...
};
//Informações de memória do processo atual.
process_memory_info_t *pmiCurrent;
//...


/*
 * physical_memory_info_d:
 *
 *     Informações sobre a memória física.
 *     O arquivo system.h deve usar isso. 
 */

typedef struct physical_memory_info_d physical_memory_info_t;
struct physical_memory_info_d
{
	object_type_t objectType;
	object_class_t objectClass;
	
	//?? dúvidas.
	unsigned long Total;     //Total de memória física.(RAM).
	unsigned long InCache;   //Parte do total que está em cache.(foi paginada e está em cache).
	unsigned long Free;      //Livre.(Existe na RAM mas não foi paginada??).
    //...	
};
physical_memory_info_t *pmiMemoryInfo;
//...


/*
 * memory_info_d:
 *     Informações sobre a memória.
 *     Isso pode ser usado pela configuração do sistema. 
 */

typedef struct memory_info_d memory_info_t;
struct memory_info_d
{
	object_type_t objectType;
	object_class_t objectClass;
	
    //Physical.
	unsigned long TotalP;
    unsigned long AvailableP;
    
	//Virtual
	unsigned long TotalV;
    unsigned long AvailableV;
};

memory_info_t *miMemoryInfo;
//...


/*
 *****************************************************************
 * mmblock_d:
 *     Estrutura para memory blocks.
 *     Temos vários blocos de memória espalhados em lugares diferentes 
 * dentro de um heap.
 *     Essa estrutura é usada pelo kernel para controlar as áreas de memória
 * alocadas dinâmicamente dentro do heap do kernel. Porém poderemos
 * usar essa mesma estrutura para alocar memória em outros heaps. Como o heap 
 * de um processo ou o heap de um desktop. @todo: Para isso essa estrutura 
 * poderia conter informações sobre qual heap estamos usando. Mas me parece 
 * que o tamanho do header deve ser fixo.
 *
 * @todo: 
 * Os blocos precisam de alguma organização. 
 * Por enquanto, o total é 256 heaps de tamanhos diferentes.
 *
 * Os blocos formarão uma lista encadeada que será percorrida para se 
 * encontrar um bloco vazio. (walk).
 *
 * *Importante: A memória será organizada em bancos, que conterão memória 
 * privada e memória compartilhada. Os blocos de memória e os heaps 
 * precisam estar associadoas aos bancos, que conterão informações sobre 
 * processos e usuários. @todo:
 * Obs: Os bancos estão definidos em bank.h
 * 
 * Obs: Um heap de processo tem vários blocos dentro.
 *
 * *IMPORTANTE: 
 *     Talvez tenhamos algum limite para o tamanho dessa estrutura 
 * em especial. (Não incluir nenhuma variável por enquanto!).
 *****************************************************************
 */ 

struct mmblock_d 
{
	
	// Essa estrutura é para gerenciar áreas de memória alocadas dinamicamente 
	// dentro do heap do processo kernel. Alocadas em tempo de eecução.
	
	// @todo: 
	// Talvez não seja possível mudar essa estrutura. Éla é diferente.
	// Portanto não definiremos inada o tipo de objeto que ela é e nem a classe.
	
	//object_type_t objectType;
	//object_class_t objectClass;
	
    //Identificadores.	
	unsigned long Header;      //Endereço onde começa o header do heap. *Importante.
	unsigned long headerSize;  //Tamanho do header em bytes.
	unsigned long Id;          //Id do header.
	unsigned long Used;        //Flag 'usado' ou 'livre'.
	unsigned long Magic;       //Magic number. Ver se não está corrompido.
	
	//Status.
	unsigned long Free;           //Se o bloco esta livre ou não.
	
	//Mensuradores. (sizes).	
	unsigned long requestSize;    //Tamanho, em bytes, da área solicitada.
	unsigned long unusedBytes;    //Quantidade de bytes não usados na área do cliente.	
	unsigned long userareaSize;   //Tamanho da área reservada para o cliente. 
	                              //(request size + unused bytes). 
								  
	//@todo: 
	//    Incluir quando possível.
    // Lembrando que talvez o tamanho dessa estrutura seja fixo.
    // Talvez não mudaremos nada no tamanho dela.	
	//struct heap_d *heap;							  
	
    // User area. 
	// (Onde começa a área solicitada).
	unsigned long userArea;    //Início da área alocada.
	
	// Footer.
	unsigned long Footer;    //Endereço do início do footer.
	
	// Process info.
    // (Pertence à qual processo?).	
	int processId;
	struct process_d *process;
	
	//
	// Continua ?? ... 
	// Talvez não pode.
	//
	
	// IMPORTANTE: 
	// Talvez temos algum limite para o tamanho dessa estrutura em especial. 
	// Não inluir nada por enquanto.
	
	// Navegação
	struct mmblock_d *Prev;
	struct mmblock_d *Next;
};
struct mmblock_d *current_mmblock;

 
//Lista de blocos. 
//lista de blocos de memória dentro de um heap.
//@todo: na verdade temos que usar lista encadeada. 
unsigned long mmblockList[MMBLOCK_COUNT_MAX];  


/*
 ****************************************************************
 * page_frames_d:
 *     Guarda informações sobre um 'page frame' na memória física.
 *     @todo: Incluir todas as informações necessárias.
 */

struct page_d
{
	
	//identificador da estrutura.
	//é um índice na lista de páginas do pagedpool.
	int id;
	
	int used;
	int magic;
	
	// Identificador de frame.
	// (pa/4096)
	int frame_number;
	
	//Não pode ser descarregado para o disco.
	//Não pode ser alterado.
	int locked;             
	
	//A página está livrea para uso pelos processos.
	int free;    
	
	//Contador de referências.
    int ref_count;
	
	//navegação
    struct page_d *next;	
};
 

// #importante
// Pool de memória paginável usado para alocação.
// Aqui ficam os ponteiros para estrutura do tipo page.

unsigned long pageAllocList[PAGE_COUNT_MAX];


/*
 * frame_pool_d:
 *     Estrutura para uma partição da memória física.
 *     Uma partição da memória física é chamada de framepool.
 *     Cada framepool tem 1024 frames.
 *     @todo: Poderia ser framepool_d ??
 */

struct frame_pool_d
{
	//object_type_t objectType;
	//object_class_t objectClass;
	
	//Índice na lista de frame pools;
	int id;
	
	int used;
	int magic;
	
	//Não pode ser modificada.
	int locked;
	
	//Endereço do início do framepool.
	// va ou pa ??
	unsigned long address; 
	
	//Qual processo é o dono desse framepool.
	struct process_d *process;
	
	struct frame_pool_d *next;
};

//
// Cada framepool abaixo é o framepool inicial de uma região.
// Uma regisão pode ter vários framepools.
//

//kernel space.
struct frame_pool_d *framepoolKernelSpace;            //0x00000000  Kernel Space. Início do kernel space.

//user space
struct frame_pool_d *framepoolSmallSystemUserSpace;   //0x00400000  Para um sistema pequeno o kernel space tem 4MB.
struct frame_pool_d *framepoolMediumSystemUserSpace;  // 
struct frame_pool_d *framepoolLargeSystemUserSpace;   //0x40000000  Para um sistema grande o kernel space tem um giga. 
//...

//Cada front buffer é uma placa de vídeo.
struct frame_pool_d *framepoolFrontBuffer1;   //Início do linear frame buffer 1.
struct frame_pool_d *framepoolFrontBuffer2;   //Início do linear frame buffer 2.
struct frame_pool_d *framepoolFrontBuffer3;   //Início do linear frame buffer 3.
struct frame_pool_d *framepoolFrontBuffer4;   //Início do linear frame buffer 4.
//...

//Backbuffer
struct frame_pool_d *framepoolBackBuffer1;   //Início do backbuffer.
struct frame_pool_d *framepoolBackBuffer2;   //Início do backbuffer.
struct frame_pool_d *framepoolBackBuffer3;   //Início do backbuffer.
struct frame_pool_d *framepoolBackBuffer4;   //Início do backbuffer.
//...


//Área onde poderemos alocar frames para os processos usarem...
//Esse é o framepool inicial de usa áre grande de memória.
struct frame_pool_d *framepoolPageableSpace;   


//Current.
struct frame_pool_d *framepoolCurrent;
//...

//struct frame_pool_d *framepoolKernelPagedPool;
//struct frame_pool_d *framepoolKernelNonPagedPool;
//struct frame_pool_d *framepoolUserPagedPool;
//struct frame_pool_d *framepoolUserNonPagedPool;

//
//   **** PAGEABLE AREA ****
//



unsigned long gPagedPollStart;
unsigned long gPagedPollEnd;


//Obs: ISSO É UM TESTE.
//Número máximo de framepools na área de alocaçao de frames.
//Obs: Isso é uma espécie de cache. Porém cache é coisa de disco.
//
// ( 1 * 4MB) =   4 MB.
// ( 2 * 4MB) =   8 MB. (Usando esse num sistema de 32mb de ram).
// ( 4 * 4MB) =  16 MB.
// ( 8 * 4MB) =  32 MB.
// (16 * 4MB) =  64 MB.
// (32 * 4MB) = 128 MB.
//

//#define PAGEABLE_FRAMEPOOL_MAX 1
#define PAGEABLE_FRAMEPOOL_MAX 2          //usando 8 MB para frames sob demanda.
//#define PAGEABLE_FRAMEPOOL_MAX 4
//#define PAGEABLE_FRAMEPOOL_MAX 8
//#define PAGEABLE_FRAMEPOOL_MAX 16
//#define PAGEABLE_FRAMEPOOL_MAX 32



//
// Número máximo de índices de framepool que serão usados nessa área de 
// alocação de frames.
// *** Uma certa quantidade de framepools serão usados
// para alocação de frames para os processos. Durante
// a alocação sobre demanda os frames usados virão dessa área de memória.
//
//
//

int g_pageable_framepool_index_max;


//List.(1024 framepools de 4MB dá 4GB).
unsigned long framepoolList[FRAMEPOOL_COUNT_MAX];


//Lista de framepools livres.
//int framepoolFreeList[FRAMEPOOL_COUNT_MAX]
//frame_pool_t *framepoolFreeListHead;



//frame pool atual.
int g_current_framepool;


//o indice do framepool da user space para qualquer tamanho de memória.
int g_user_space_framepool_index;


//O máximo de framepools possíveis dado o tamanho da memória física.
unsigned long g_framepool_max;


//Tamanho máximo da memória física.
unsigned long g_total_physical_memory;


//Contabilidade. kernel(talvez deva fazer uma estrututra) MS.
//Memória usada pelo kernel.
//+Paginada. paged
//+não paginada. nonpaged
//+fisica paginada
//+virtual paginada 
//+paginada limite
//+naõ pagianda limite.
//
unsigned long g_kernel_paged_memory;
unsigned long g_kernel_nonpaged_memory;

// **** GERENCIA DE MEMÓRIA FÍSICA. ****
//MS - Windows 
// +Resevada para hardware.
// +Em uso.
// +Modificada. 
// +Em espera.
// +Livre.
// ?? Aqui não conta a memória de vídeo, somente o tamanho da memória ram física.
// A memória de vídeo está normalmente no topo da memória física real. Endereço 
// além do tamanho da memória ram.
//


// **** GERENCIA DE MEMÓRIA FÍSICA. ****
//MS - Windows 
// + Total.
// + Em cache.
// + Disponível.
// + Livre.
//



//tipo de sistema baseado no tamanho da memória.
typedef enum {
	stNull,
    stSmallSystem,
    stMediumSystem,
    stLargeSystem,
}mm_system_type_t;


//salva o tipo de sistema baseado no tamanho da memória.
int g_mm_system_type;


//
// ## Physical memory ##
//

	// Small systems.
	unsigned long SMALL_kernel_address;
	unsigned long SMALL_kernel_base;
	unsigned long SMALL_user_address;
	unsigned long SMALL_vga_address;
	unsigned long SMALL_frontbuffer_address;
	unsigned long SMALL_backbuffer_address; 
	unsigned long SMALL_pagedpool_address; 
	unsigned long SMALL_heappool_address;
	 
	unsigned long SMALL_extraheap1_address;
    unsigned long SMALL_extraheap2_address; 
    unsigned long SMALL_extraheap3_address; 
    //...

    // Medium systems.	
	unsigned long MEDIUM_kernel_address;
	unsigned long MEDIUM_kernel_base; 
	unsigned long MEDIUM_user_address; 
	unsigned long MEDIUM_vga_address; 
	unsigned long MEDIUM_frontbuffer_address; 
	unsigned long MEDIUM_backbuffer_address; 
	unsigned long MEDIUM_pagedpool_address;  	
    unsigned long MEDIUM_heappool_address; 
    
	unsigned long MEDIUM_extraheap1_address; 	
    unsigned long MEDIUM_extraheap2_address; 
    unsigned long MEDIUM_extraheap3_address; 
	
    // Large systems.
	unsigned long LARGE_kernel_address;
	unsigned long LARGE_kernel_base;
	unsigned long LARGE_user_address;
	unsigned long LARGE_vga_address;
	unsigned long LARGE_frontbuffer_address;
	unsigned long LARGE_backbuffer_address;
	unsigned long LARGE_pagedpool_address; 
    unsigned long LARGE_heappool_address;
    
	unsigned long LARGE_extraheap1_address;
    unsigned long LARGE_extraheap2_address; 
    unsigned long LARGE_extraheap3_address; 




//base     = base memory retornada pelo cmos
//other    = (1MB - base). (Shadow memory = 384 KB)
//extended = retornada pelo cmos.
//total    = base + other + extended.

unsigned long memorysizeBaseMemory;
unsigned long memorysizeOtherMemory;
unsigned long memorysizeExtendedMemory;
unsigned long memorysizeTotal;


unsigned long memorysizeInstalledPhysicalMemory;

unsigned long memorysizeTotalPhysicalMemory;
unsigned long memorysizeAvailablePhysicalMemory;


//??
// Quantidade de memória em uso.
unsigned long memorysizeUsed;

//??
//Quantidade de memória livre.
// ? = total - used.
unsigned long memorysizeFree;


//
// ## Used Memory support ##
//

unsigned long mm_used_kernel_area;  // start = 0 size = 4MB
unsigned long mm_used_user_area;    // start = 0x400000 size = 4MB
unsigned long mm_used_backbuffer;   // start = 0x800000 size = 4MB
unsigned long mm_used_pagedpool;    // start = 0xC00000 size = 4MB  

//area de memória onde ficarão heaps para os processos.
unsigned long mm_used_heappool;     // start = 0x01000000 size = 4MB   
	
// #importante
// os processos init, shell e taskman do gramado core são especiais
// por isso receberão heaps especiais.



// Extra heaps.

//unsigned long mm_used_gramadocore_init_heap;     // start = (0x01000000 + 0x400000) size = 4MB
//unsigned long mm_used_gramadocore_shell_heap;    // start = (0x01000000 + 0x800000) size = 4MB
//unsigned long mm_used_gramadocore_taskman_heap;  // start = (0x01000000 + 0xC00000) size = 4MB

unsigned long mm_used_extraheap1;  // start = (0x01000000 + 0x400000) size = 4MB
unsigned long mm_used_extraheap2;  // start = (0x01000000 + 0x800000) size = 4MB
unsigned long mm_used_extraheap3;  // start = (0x01000000 + 0xC00000) size = 4MB




unsigned long mm_used_lfb;          // start = ?? size = 4MB

//#todo
//unsigned long mm_used_
//more ...


//
//  ## virtual memory ##
//

unsigned long memorysizeTotalVirtualMemory;
unsigned long memorysizeAvailableVirtualMemory;


// Tamanho dado em bytes.
#define SMALLSYSTEM_SIZE  ( 32*1024*1024)
#define MEDIUMSYSTEM_SIZE ( 64*1024*1024)
#define LARGESYSTEM_SIZE  (128*1024*1024)

// Tamanho do sistema, dado em KB.
#define SMALLSYSTEM_SIZE_KB  ( 32*1024)
#define MEDIUMSYSTEM_SIZE_KB ( 64*1024)
#define LARGESYSTEM_SIZE_KB  (128*1024)

// #todo
// Tamanho do sistema, dado em MB.
//#define SMALLSYSTEM_SIZE_MB  ( 32)
//#define MEDIUMSYSTEM_SIZE_MB ( 64)
//#define LARGESYSTEM_SIZE_MB  (128)


// Tamanho so sitema, dado em quantidade de páginas de 4KB.
#define SMALLSYSTEM_SIZE_PAGES  ( ( 32*1024*1024) / 4096 )
#define MEDIUMSYSTEM_SIZE_PAGES ( ( 64*1024*1024) / 4096 )
#define LARGESYSTEM_SIZE_PAGES  ( (128*1024*1024) / 4096 )





//
// Protótipos.
//

//#bugbug
//isso é um improviso,rever ...PERIGO
unsigned long get_table_pointer(void);


//Mostra o inteiro que está na entrada especificada pelo argumento,
//dado um determinado diretório (va)
void mmShowPDE (int index, unsigned long pd_va);
void mmShowPDEForAllProcesses (int entry_number);

void memoryShowMemoryInfo (void);

//
// Init support.
//

int init_mm (void); 

int init_stack (void);

//Configura paginação.
int SetUpPaging (void);    


// Coloca o endereço do diretório de páginas de um processo
// no registrador cr3 da arquitetura Intel.
void x86_SetCR3 (unsigned long pa);


//mapeando o nic principal.
//considerando que tenhamos mais de uma placa de rede, 
//esse mapeamento só será válido para o primeiro.
unsigned long 
mapping_nic1_device_address ( unsigned long pa );

//mapeando ahc1.
unsigned long mapping_ahci1_device_address ( unsigned long pa );


//
// Directory.
//

//deve retornar o endereço do diretório de páginas criado,
//que é um clone do diretório de páginas do kernel.
void *CreatePageDirectory (void);


//
// Page tables.
//

// Cria uma pagetable em um dado diretório de páginas.
// Uma região de 4MB da memória física é mapeanda nessa pt.

void *CreatePageTable ( unsigned long directory_address_va, 
                        int dir_index, 
                        unsigned long region_address );


int pEmpty (struct page_d *p);
void freePage (struct page_d *p);
void notfreePage (struct page_d *p);	

int firstSlotForAList (int size);

//?? Talvez tenha que mudar de nome.
//checar se estamos lidando com páginas ou com frames.
void initializeFramesAlloc (void);


//construtur
//cria uma estrutura válida de página
//cujo ponteiro ficará em uma lista.

void *page (void);  	

void *allocPages (int size);

 //aloca uma página e retorna seu endereço virtual inicial
void *newPage (void);            


void testingPageAlloc (void);     //@todo: Rotina de teste. deletar.




unsigned long 
virtual_to_physical ( unsigned long virtual_address, 
                      unsigned long dir_va ) ;


//
// Debug support.
//

void show_memory_structs (void);

//mostra as estruturas de pagina usadas para paginação no pagedpool.
void showFreepagedMemory ( int max );


//
// GC. #test
//

int gc (void);
int gcGRAMADO (void);
int gcEXECUTIVE (void);
int gcMICROKERNEL (void);
int gcHAL (void);



//
// End.
//


