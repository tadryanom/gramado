/*
 * File: mk/ps/process.h
 *
 * Descrição:
 *     Header principal para as rotinas de gerenciamento de processos.
 *
 * Classes de processos (tipo de nível):
 * ====================================
 *    PB - Processos incluídos no Kernel Base.
 *    P0 - Processos em ring0.
 *    P1 - Processos em ring1.
 *    P2 - Processos em ring2.
 *    P3 - Processos em ring3, User Mode.
 *
 *
 * @todo: Taskman e outros programas gerenciadores de tarefas precisam de informações
 * sobre os processos. A barra de tarefas também precisa.
 * @todo: Contagem de processos.
 * @todo: Contar a quantidade de objetos alocados para um processo.
 *        contar a quantidade de objetos por classe de objetos.
 *        Saber a classe dos objetos alocados é importante, pois isso
 *        oferece informações sobre o comportamento do processo. 
 * @todo: Fazer contagem de faltas de página.
 * @todo: suporte a workset.(quantidade de memória numa faixa de tempo.)
 * +em qual cpi o processo está.?
 * + com qual cpu o processo tem afinidade?.
 * + o processo está confinado ou não.?
 * +prioridade básica e atual?
 * medir quantidade de operações de leitura e saída.
 * +name, pathname e cmd(command line).
 *
 * Histórico:
 *     Versão: 1.0, 2015 - Esse arquivo foi criado por Fred Nora.
 *     Versão: 1.0, 2016 - Aprimoramento geral das rotinas básicas.
 *     ...
 */


//#todo;
//#define Get_PDE_Index(va) (((unsigned long)(va)) >> 22)
//#define Get_PTE_Index(va) ((((unsigned long)(va)) << 10) >> 22)


struct process_d *xxxClonedProcess;

//#bugbug
//talvez aqui nao seja o melhor lugar pra definir isso.
#define gramado_pid_t pid_t


//Limite para criação de processos. 
#define PROCESS_COUNT_MAX 1024   
 
//
//#define FIRST_PROCESS processList[0]
//#define LAST_PROCESS  processList[PROCESS_COUNT_MAX-1] 

 
//
// Endereços virtuais usados pelos processos.
//


// Image. 
// (Base da imagem de um processo de usuário).
//
// "Todo processo terá seu próprio diretório de páginas
//  e será carregado no endereço virtual 0x400000, logicamente
//  cada processo será carregado em um endereço físico diferente."

#define UPROCESS_IMAGE_BASE 0x400000 

//Process Limit. (User process) 
//(O limite é o início do kernel).
#define UPROCESS_PROCESS_LIMIT 0xC0000000    



// Heap.
// Base default do heap do processo.
// "Endereço virtual de onde começa o heap de um processo,
//  evidentemente, cada processo terá seu heap em um 
//  endereço físico diferente".
//
#define UPROCESS_DEFAULT_HEAP_BASE  0x80000000 
//Tamanho default do heap do processo.  
#define UPROCESS_DEFAULT_HEAP_SIZE  0x2000     

//Stack.
//Deslocamento default do início da pilha em relação ao início do kernel. #bugbug
#define UPROCESS_DEFAULT_STACK_OFFSET 0x2000   
//Base default da pilha do processo.
#define UPROCESS_DEFAULT_STACK_BASE ( UPROCESS_PROCESS_LIMIT - UPROCESS_DEFAULT_STACK_OFFSET )  
//Tamanho da pilha do processo.   
#define UPROCESS_DEFAULT_STACK_SIZE 0x2000    
 
 

 
//
// Bases para a contagem de processos, do sistema e de usuários.
// 
 
//Primeiro índice na contagem das processos do sistema.
#define SYSTEM_BASE_PID 0
//Primeiro índice na contagem das processos dos usuários.  
#define USER_BASE_PID 100    
 
 
/*
 * Constantes para níveis de prioridade.
 */
 
//Definições principais. 
#define PRIORITY_LOW4      1  //4
#define PRIORITY_LOW3      2  //3
#define PRIORITY_LOW2      3  //2
#define PRIORITY_LOW1      4  //1 
#define PRIORITY_NORMAL    5  //*0 (Normal).
#define PRIORITY_HIGH1     6  //1
#define PRIORITY_HIGH2     7  //2
#define PRIORITY_HIGH3     8  //3
#define PRIORITY_HIGH4     9  //4

//Definições secundárias.
#define PRIORITY_LOW        PRIORITY_LOW1
#define PRIORITY_MIN        PRIORITY_LOW4
#define PRIORITY_HIGH       PRIORITY_HIGH1 
#define PRIORITY_MAX        PRIORITY_HIGH4



// #todo: Criar uma variável para esse multiplicador.
// para fazermos testes;
//unsigned long g_timeslice_multiplier;
//#define TIMESLICE_MULTIPLIER 1
//#define TIMESLICE_MULTIPLIER 2
#define TIMESLICE_MULTIPLIER 3
//...




/*
 * Constantes para níveis de quantum.
 * Tempo de processamento atribuido pelo scheduler à cada processo.
 * dado em quantidades de ticks ...
 * para saber quanto tempo tem que multiplicar por 10ms ... que é 
 * o tempo de cada interrupção ... e somar o tempo perdido com taskswitch ...
 *  100ms + 5ms(que o timer fica esperando o kernel habilitar as interrupções).
 */

// #test
#define QUANTUM_BASE   (PRIORITY_NORMAL*TIMESLICE_MULTIPLIER)
#define QUANTUM_LIMIT  (PRIORITY_MAX *TIMESLICE_MULTIPLIER)

// #test
// Limite de tempo esperando.
#define READY_LIMIT   (PRIORITY_MAX *TIMESLICE_MULTIPLIER)
#define WAITING_LIMIT (PRIORITY_MAX *TIMESLICE_MULTIPLIER)
#define BLOCKED_LIMIT (PRIORITY_MAX *TIMESLICE_MULTIPLIER)
 
 
//Lista de status na criação de um processo.     
#define ERRO_SLOT_OCUPADO  0xfffff    //Slot ocupado.      
#define ERRO_DEFAULT       0xffffe
//...


//Process runtime stack.
//??? Deve ser o limite máximo para a pilha de um processo.
#define MAXSTACK 128    //dwords.
 
//Número total de slots para criação de processo.
//@todo: deletar, definido em threads. ??? 
#define NUMERO_TOTAL_DE_SLOTS 256   
 
#define PROCESS_MAGIC 1234
 
/*
 * Globais.
 *
 * @todo: Talvez o certo é não ter globais aqui, e
 *        as estruturas e variáveis relativas ao gerenciamento
 *        de processos fique dentro do arquivo process.c.
 *        Encapsulamento.?? 
 */ 
 
 

/*
 * process_state_t
 *     Status de um processo.
 *     @todo: Pode-se usar mais status.
 *            como estado de transição.
 *  Os status de um processo são diferentes do status de uma thread.
 */ 

typedef enum {
    PROCESS_CREATED,
    PROCESS_INITIALIZED,
    PROCESS_RUNNING,
    PROCESS_BLOCKED,
    PROCESS_TERMINATED,
    PROCESS_IN_MEMORY,        //O processo está carregado na memória.
    PROCESS_OUT_OF_MEMORY,    //O processo não está carregado na memória.
	//...
}process_state_t;


/* 
 appmode_t
 
 Importante:
 
 APPMODE_TERMINAL = O kernel cria uma estrutura de terminal 
 com uma janela associada a essa estrutura, essa janela será a 
 janela de terminal para o aplicativo.
 APPMODE_WINDOW = O kernel não cria estrutura de terminal para 
 esse processo e o processo criará janelas.
 */

typedef enum {
    APPMODE_NULL,      // Isso se aplica ao processo kernel e ao processo idle por exemplo.
    APPMODE_TERMINAL,  // O kernel cria uma janela de terminal para o aplicativo.
    APPMODE_WINDOW,    // O kernel não cria janela de terminal para o aplicativo
}appmode_t;


/*
 * Estruturas para processos.
 */

  
/*
 #todo: Pensando nisso
 o kernel vai armazenar todas essas informações sobre process?  
struct process_info_d
{
    //#todo object header
    
	// @todo:
	// +name     (Nome=EXEMPLO.BIN)
	// +pathname (Caminho=/root/boot/EXEMPLO.BIN)
	// +cmd      (linha de comando ex:EXEM ) 
	
    // process name
    char name[32];      // (PROCESS-NAME-1)
    char pathname[32];  // (Caminho=/root/boot/EXEMPLO.BIN)
    char cmd[32];       // (linha de comando ex:EXEM )
    //env variables?
};  
*/
  
/*
 * process_d: 
 *
 *    PCB - Process Control Block.
 *
 *    Estruturas para processos.
 *    Estrutura onde se guarda informações sobre os processos.
 *    Cada estrutura terá informações necessárias para
 *    gerenciar um processo específico.
 *    São os SLOTS. 
 *
 *    Obs:
 *        Devem ter informações sobre o carregamento,
 *        se estão na memoria ou não, 
 *        se estão em processo de transição. etc.
 *        *IMPOTANTE: Uso de cotas de recursos.
 *
 *    @todo: 
 *        Deve-se começar listando os recursos que o processo usa.
 *        Ex: Lista de arquivos, 
 *            lista de recursos que pretende usar.
 *            permissões, acessos, 
 *            (isso tem a ver com o usuário, dono do processo).
 *
 *     Obs: Fica por último o que for referenciado com menor frequência.
 *          Onde ficarão os diretórios e as páginas dos processos.(mm)
 *          O kernel precisa aloca memoria para os PDs PTs.
 *          O kernel precisa alocar memória para Heap e Stack dos processos.
 *          //...
 */

struct process_d 
{
    // Controle do objeto do tipo processo.
 
    object_type_t objectType;
    object_class_t objectClass;
    struct object_d *object;

    int used;  
    int magic; 
    

    // Objetos abertos pelo processo.
    unsigned long Objects[64];

    // Usado para pipes sem nome por exemplo.
    unsigned long Streams[NUMBER_OF_FILES];



	//
	//  Identificadores.
	//
 
	//PID, (Process Identification), 
	//Número que identifica unicamente um processo.	
	//PPID, (Parent Process Identification),
	//Número de identificação do processo pai.	
	//UID, (User Identification),
	//Número de identificação do usuário que criou o processo.	
	//GID, (Group Identification),
	//Número do grupo do dono do processo.

    pid_t pid;
    pid_t ppid;

    uid_t uid;
    gid_t gid;

	// State.
	// flag ?
    process_state_t state; 

	//plano de execução.
    int plane;

	// error.
	//unsigned long error; 

	// @todo:
	// +name     (Nome=EXEMPLO.BIN)
	// +pathname (Caminho=/root/boot/EXEMPLO.BIN)
	// +cmd      (linha de comando ex:EXEM ) 

	//char *pathname;              //@todo: Incluir.	
	char *cmd;                     //Nome curto que serve de comando.
	char *name;                    //Nome do processo. 
	//unsigned long name_address;    //@todo: não usar isso.

    //#test
    //Assim fica mais fácil enviar para o aplicativo.
    char __processname[64];    // HOSTNAME_BUFFER_SIZE
    size_t processName_len;    // len 

    //
    // Standard input.
    //
    
    // #importante
    // De onde vem o o input do processo. (stdin)
    // O stdin pode vim de um terminal. Pois um terminal
    // pode estar gerenciando o input de teclado ou mouse e
    // transferindo os dados para o processo através de uma 
    // disciplina de linhas.
    // ex: #todo INPUTTYPE_TTY INPUTTYPE_RAW ...
    int input_type;
    
	//
	// tty support
	//
    
    // Essa é a tty do processo.
    // Ela será master se o processo for um shell e
    // Será slave se o processo for um terminal.
    // O terminal(slave) encontrará o shell(master) em tty->link.
    struct tty_d *tty;
    
    // Um buffer no app en ring3
    // onde o driver de rede pode colocar conteúdo e depois
    // avisar o processo via mensagem.
    char *net_buffer;

 
    // Qual é apersonalidade do processo.
    // Ele deve agir como unix-like, gramado-like, etc ?
    int personality;

	//Importante:
	//isso substituirá a flag 'terminal'
	//APPMODE_TERMINAL = O kernel cria uma estrutura de terminal 
	//com uma janela associada a essa estrutura, essa janela será a 
	//janela de terminal para o aplicativo.
	//APPMODE_WINDOW = O kernel não cria estrutura de terminal para 
	//esse processo e o processo criará janelas.
	
	appmode_t appMode;

	//
	//    ****  Banco de dados ****
	//


	// Obs: 
	// Um processo é um cliente de banco de dados.
	// Um processo tem contas conjuntas e pessoais.
	// Um processo poderá compartilhar esses objetos.	

	//
	// BANCOS
	//

	//Acesso ao banco de dados do kernel. (não é uma lista).
	struct bank_d *kdb;

	//Lista de acessos à bancos de contas conjuntas.
	struct bank_d *gdbListHead;

	//Lista de acessos à bancos de contas pessoais.
	struct bank_d *ldbListHead;


	//
	// CONTAS
	//

	//Lista de contas conjuntas que o processo tem.
	struct aspace_d *aspaceSharedListHead;

	//Lista de contas pessoais que o processo tem.
	struct aspace_d *aspacePersonalListHead;

	//Lista de contas conjuntas que o processo tem.
	struct dspace_d *dspaceSharedListHead;

	//Lista de contas pessoais que o processo tem.
	struct dspace_d *dspacePersonalListHead;

	//Testing...
	//Process Page Table. (PPT)
	//Quais são as páginas que o processo está usando e onde elas estão.
	//na tabela tem que ter: O número da página. onde ela está, se no disco ou se na memória
	//qual é o número do pageframe da página e qual o status de modificação
	// Bom, acho que pra isso, o processo deve trabalhar em um número limitado de pagetables
	// pois o número do frame deve ser o índice da pte dentro da page table.
	// Uma pagetable tem 1024 entradas, garantindo um número de 1024 frames, o que dá 4MB.
	// Mas se um processo tiver mais que 4MB? Então o diretório de páginas do processo
	// terá que ter mais de uma page table.
	// Obs: O kernel deve manter uma lista de frames que podem ser usados.
	//      na hora de criar uma pagetable pra um page directory de um processo
	// é necessário pegar na lista de frames 1024 frames livres ou quanto for necessário.

	// **** IMPORTANTE ****
	// Uma lista de framepool. (Lista de partições de memória física).
	// Cada framepool é composto de 1024 frames.
	// Obs: *IMPORTANTE: Quando um processo é criado, pelo menos um framepool 
	// deve ser atribuído a ele, mesmo antes de mapear os frames desse 
	// framepool em alguma pagetable do page directory do processo.

	struct frame_pool_d *framepoolListHead;


	//Quantidade de memória física usada pelo processo que não pode ser compartilhada
	//com outros processos. (em KB).
	unsigned long private_memory_size;

	//Quantidade de memória física usada pelo processo que pode ser compartilhada
	//com outros processos. (em KB).
	unsigned long shared_memory_size;

	//Quantidade de memória usada por um processo em determinado espaço de tempo.
	// workset = (private + shared);
	unsigned long workingset_size;
	unsigned long workingset_peak_size;	


	//Qualquer pagefault deve ser registrada na estrutura do processo corrente.
	//?? não seria na thread ??
	unsigned long pagefaultCount;
	//...

	//ticks running ..
	//unsigned long Cycles;  // ?? double ??  
	
	//quantas vezes no total o dispacher atuou sobre ele.
	//Essa contagem não deve ser feita na thread.
	//Ou colocaremos aqui o total de todos os context switches das threads ??
	//unsigned long ContextSwitches;   

	// Importante:
	// working set support.
	// The working set of a process is the set of pages in the 
	// virtual address space of the process that are currently 
	// resident in physical memory. 
	// Quantas trocas de context sofreu durante um determinado tempo de análise.
	// Esse deve ser o mesmo tempo de análise usado para calcular o working set.


	//unsigned long ContextSwitchesDelta;  


	//
	// ## MEMORY SUPPORT ##
	//

	// image = Imagem do programa principal do processo.
	// heap  = Heap do processo.
	// stack = Stack do proceso.

	// #bugbug
	// Me parece que isso considera que o processo só tem um programa.
	// Como ficaria no caso do processo ter vários programas.
	// Podemos fazer aqui só as informações para o programa principal.
	// Para os outros programas teremos apenas uma lista de ponteiros
	// para as estruturas que gerenciam eles.

	// ORDEM: 
	// O que segue é referenciado durante o processo de task switch.

	
	// Page directory information:
	// ==========================
	//     Todo processo deve ter seu próprio diretório.
	//     As threads usam o diretório do processo ao qual pertencem.
	//     O endereço do diretório é carregado no CR3.
 
	 
	unsigned long DirectoryVA;                  
	unsigned long DirectoryPA;

	
	//ponteiro para a estrutura do diretório de páginas do processo.
	struct page_directory_d *page_directory;  

	//
	// Image support.
	//
	
	// #IMPORTANTE
	// Com base na origem da imagem e no seu tamanho podemos
	// determinar a quantidade de páginas que o programa principal do processo
	// está usando.
	// Como o programa foi caregado pelo boot loader, ainda não temos a lista
	// de páginas usadas por esse processo.
	// #obs: A lista é grande. Então devemos fazer apenas um ponteiro para 
	// ela, ou colocarmos um ponteiro de estrutura head de uma lista encadeada.
	// #importante: esssa estrutura tem que ser simples. Com poucos elementos.
	// Poderemos usar essas informações para clonar o processo.


	// Base da imagem do processo.
	// Tamanho da imagem do processo.
	// Quantas páginas foram usadas por essa imagem. ImageSize/PageSize
	 
	unsigned long Image; 
	unsigned long ImagePA; 
	
	unsigned long ImageSize;      
	unsigned long PagesPerImage; 

	//usado no fork()
    unsigned long childImage; 
    unsigned long childImage_PA;  
    //unsigned long childImage2; 
	
	//#todo: estrutura com informações sobre a imagem do processo.
	//see: pc/image.h
	struct image_info_d *image_info;
	
	//#test
	//struct page_control_t *page_list_head;


	// ## Heap ##     

	//#importante 
	unsigned long Heap;            //Endereço do início do Heap do processo.
	unsigned long HeapEnd;
	unsigned long HeapSize;        //Tamanho do heap.
	
	//?? Isso serve para manipulação do heap do processo.
	unsigned long HeapPointer;     //Ponteiro do heap do processo para o próxima alocação.
	unsigned long HeapLastValid;   //Último ponteiro válido.
	unsigned long HeapLastSize;    //Último tamanho alocado..	
	//struct heap_d *processHeap;  //@todo: Usar essa estrutura.


	//  ## Stack ##

	unsigned long Stack;          //Endereço do início da Stack do processo.
	unsigned long StackEnd;
	unsigned long StackSize;      //Tamanho da pilha.	
	unsigned long StackOffset;    //Deslocamento da pilha em relação ao início do kernel.	
	//struct stack_d *processStack;  //@todo: Criar essa estrutura.

	// Teste: 
	// Blocos de memoria usados pelo processo.

	//struct mmblock_d mmBlocks[32];    //estruturas 
	//unsigned long mmblockList[32];    //ponteiros para estruturas.

	//Muitas informações sobre a memória usada pro um processo.
	//struct process_memory_info_d *processMemoryInfo;


	//
	//  Environment.
	//


	//IOPL of the task. (ring).
	unsigned long iopl;      

	// Priority.
	// Um processo tem uma prioridade básica estática e também uma prioridade 
	// atual dinâmica, que pode ser incrementada ou decrementada. Se afastando 
	// ou se aproximando da prioridade básica. Isso acontece no OpenVMS e no NT.
	
	unsigned long base_priority; //básica. 
	unsigned long priority;      //dinâmica.

	//Que tipo de scheduler o processo utiliza. (rr, realtime ...).
	//int scheduler_type;    
 
	//
	// Temporização da tarefa. 
	//
	
	unsigned long step;               //Quantas vezes a tarefa usou o processador. 
	unsigned long quantum;            //thread quantum
	unsigned long timeout;            //Tempo em modo de espera. 
	unsigned long ticks_remaining;    //rt, quanto tempo a tarefa tem disponível para ser concluida.

	//unsigned long alarm;            //Tempo para o próximo alarme, dado em ticks.

	//unsigned long ThreadQuantum;    //As threads do processo iniciam com esse quantum.

	/*
	 * QUANTUM:
	 * =======
	 *     Quantum é a cota atrituida à cada processo pelo
	 *     scheduler. (time slice) 
	 *     Esse é o tempo limite imposto pelo scheduler para
	 *     execução de um processo. Ocorre então uma preempção por tempo.
	 *      
	 *     'ProcessingTime' é atribuído pelo processo. É o quanto
	 *     ele precisa. o quanto ele deseja.
	 */
	 
	//
	// Working set support.
	// 
	 
	//unsigned long ws_number_of_frames; 
	//...
	
	//quanto por cento do tempo o processo ficou rodando.
	//é a soma do quanto ficou rodando todas as suas threads.
	unsigned long profiler_percentage_running;
	unsigned long profiler_ticks_running;
	unsigned long profiler_last_ticks;
	
	//
	//  +++++ Thread support +++++
	//
	
	//Número de threads do processo.
	
	int threadCount;     
	
	/*
	 * threadList:
	 *     Lista com ponteiros de estrutura das threads do processo.
	 *     O indice dessa lista serve para enumerálas.
	 *	 
	 *     @todo: Usar array de estruturas dinâmico. (Alocar).
	 */ 
	unsigned long tList[32];      //@todo: deletar  
	//struct thread_d *Threads;   //@todo: usar esse.
	//struct thread_d CurrentThread;

	//A primeira thead de uma lista linkada.
	struct thread_d *threadListHead;
	//struct thread_d *threadReadyListHead;
	//...


    // #importante:
    // Thread de controle
    // Usada para input de mensagens e sinais.
    // Se fechar ela, tem que fechar o processo.

    struct thread_d *control;


	// Isso pode funcionar em parceria com control, 
	// quando criarmos novos processos ou clonarmos.
	struct thread_d *extra;  
	
	
	// Tipo 
	// 0 = cpu-bound
	// 1 = i/o bound.

	int bound_type;
	
	// ??
	// preempted:
	//     flag ~ Sinaliza que uma tarefa pode ou não sofrer preempção.
	//     Uma tarefa de menor prioridade pode deixar o estado running 
	// para assumir o estado ready em favor de uma tarefa de maior prioridade
	// que assumirá o estado running.

	unsigned long preempted;

	//saved ~ Sinaliza que a tarefa teve o seu contexto salvo.
	unsigned long saved;

	//??
	unsigned long PreviousMode;

	/*
	 * event: 
	 *    Tipo de evento que fazem a tarefa entrar em modo de espera. 
	 */	
	//event_type_t event;
		
	
	/*
	 * Windows. (Janelas)
	 */
	

	//User session, room (window station), desktop.
	
	struct usession_d *usession;    //user session
	struct room_d *room;            //room (Window Station) do processo.  
	struct desktop_d *desktop;      //Desktop do processo.        
	

	//
	// ORDEM: O que segue é referenciado com pouca frequência.
	//
	
	//lista de arquivos ??
	//fluxo padrão. stdio, stdout, stderr
	//unsigned long iob[8];

	//ponteiros para as streams do fluxo padrão.
	unsigned long standard_streams[3];
	
	struct _iobuf *root;	// 4 root directory
	struct _iobuf *pwd;	    // 5 (print working directory) 
	//...


	//#todo: esse tamanho deve ser igual ao encontrado no módulo /fs.	
	char pwd_string[32];	
	
	// @todo:
	// Outros:
	//tempo de cpu.
	//prioridade básica. //Obs: prioridade poderia ser uma estrutura.
	//contagem de threads usadas no momento.
	//path name - Endereço completo do arquivo ex:/root/users/fred/text.bin
	//comando. - Comando que abre o programa.
	//Contagem de objetos sendo usado. (estatisticas ajudam melhorar o sistema.)
	//i/o read count - Contagem de leituras de disco feitas pelo processo.
	//i/o write count - Contagem de gravações de disco feitas pelo processo.
	//generic i/o - Outras operações de i/o que não são leitura e escrita em disco.
	//todal de bytes lidos do disco pelo processo.
	//total de bytes gravados no disco pelo processo.
	//generic bytes i/o. contagem de bytes para operações genéricas de i/o, excluindo disco.
	

	// wait4pid: 
	// O processo esta esperando um processo filho fechar.
	// Esse é o PID do processo que ele está esperando fechar.

	pid_t wait4pid;
	
	//Motivo do processo fechar.
	int exit_code;
	
	// Número de processos filhos.
	int nchildren;
	
	// Lista de processos filhos que estão no estado zumbi.
	// List of terminated childs
	struct process_d *zombieChildListHead;           
	
	//?? mensagens pendentes.	
	//struct thread_d *sendersList; //Lista encadeada de processos querendo enviar mensagem
	//struct thread_d *nextSender;  //próximo processo a enviar mensagem.

	//
	//   ## IPC ##
	//

	// Signal	
	unsigned long signal;
	unsigned long signal_mask;

    //#bugbug
    //deleta isso.
	//Argumentos para o procedimento de janela.
	//struct window_d *window;    //arg1.
	//int msg;                    //arg2.
	//unsigned long long1;        //arg3.
	//unsigned long long2;        //arg4.

	// diálogo com o processo.
	// importante no caso de servidores e drivers
	unsigned long dialog_address;
			
	// Navigation:
	// Prev and Next.

	struct process_d *prev;
	struct process_d *next;
};

//Os quatro principais processos.
struct process_d *KernelProcess;     //PID=0.   Ok.
struct process_d *InitProcess;       //PID=100. ?
struct process_d *ShellProcess;      //PID=101. ?
struct process_d *TaskManProcess;    //PID=103. ?

//Outros.
struct process_d *Process;           //Current.
struct process_d *idle_proc;         //Iddle. //@todo: deletar
struct process_d *cur_process;       //Current.

//Lista encadeada de processos.
struct process_d *process_Conductor2;
struct process_d *process_Conductor;
struct process_d *process_rootConductor;
struct process_d *CurrentProcess;    //Current.


/*
 *    processList:
 *        Tabela de processos.
 *
 *    **** LONG-TERM SCHEDULER FOR PROCESSES ****
 *
 *     Essa é a thread job list, ou job queue.
 *     Armazena todos os processos do sistema.
 *     os que estão residentes na memoria ram e as que não estão.
 */  

unsigned long processList[PROCESS_COUNT_MAX];


//
// @todo: Aqui pode haver outras tabelas de processos:
//

//unsigned long running_processList[8];
//unsigned long running_processList[8];
//unsigned long running_processList[8];
//unsigned long running_processList[8];
//...




/*
 * Lista de processos:
 *   Em forma de fila.
 *
 */
typedef struct proc_list_d proc_list_t;
struct proc_list_d
{
	unsigned long len;
	struct process_d *head;
	struct process_d *tail;
	
}; 
struct proc_list_d *system_procs;      //Processos do sistema.
struct proc_list_d *periodic_procs;    //Processos periódicos.
struct proc_list_d *rr_procs;          //Processos do tipo round robin.
struct proc_list_d *waiting_procs;     //Processos que estão esperando.
//...  




/*
 * process_info_d:
 *    Informações básicas sobre um processo. 
 *    Quick access.
 */

struct process_info_d 
{
	int processId;
	struct process_d *process; 	
    
	// Thread principal.
	int threadId;
	struct thread_d *thread;

    //... 	
};


/* 
 * Linux style. */

#define invalidate() \
    asm ("movl %%eax,%%cr3"::"a" (0))


//
// Protótipos de função.
//

unsigned long __GetProcessStats ( int pid, int index );

int getprocessname ( int pid, char *buffer );




// t900
//clona e executa o filho dado o nome do filho.
pid_t do_clone_execute_process (char *filename);


// t901
//clona um processo, retorna par ao pai e inicializa o processo
//filho do seu entrypoint. (#test)
pid_t do_fork_process2 (void);


/*
 ***************************************
 * do_fork_process
 *     (Função em desenvolvimento)
 *     Clona um processo sem thread.
 *     Clona o processo atual.
 *     Retorna o PID do clone.
 */

pid_t do_fork_process (void);


//cria uma estrutura do tipo processo, mas não inicializada.
struct process_d *processObject (void);


/*
 * getNewPID:
 *     Pegar um slot vazio na lista de processos.
 *     +Isso pode ser usado para clonar um processo.
 */

pid_t getNewPID (void);


// Signal.
int 
processSendSignal( struct process_d *p, 
                   unsigned long signal );


//
// Page directory support.
//
 
unsigned long GetPageDirValue (void);

unsigned long GetProcessDirectory ( struct process_d *process );

void 
SetProcessDirectory ( struct process_d *process, 
                      unsigned long Address );


//
// Process support.
//

unsigned long GetProcessHeapStart ( pid_t pid );

unsigned long GetProcessPageDirectoryAddress ( pid_t pid );

int processTesting (int pid);

void init_processes (void);

void show_currentprocess_info (void);
void show_process_information (void);


// Copia a imagem do processo que está carregada na memória.
int processCopyMemory ( struct process_d *process );

// copia os recursos do processo.
int processCopyProcess ( pid_t p1, pid_t p2 );


struct process_d *create_process ( struct room_d *room,
                                   struct desktop_d  *desktop,
                                   struct window_d *window,
                                   unsigned long base_address, 
                                   unsigned long priority, 
                                   int ppid, 
                                   char *name,
                                   unsigned long iopl,
                                   unsigned long directory_address );



//
// Finalizações.
//

void CloseAllProcesses (void);


/*
 * exit_process:
 *     exit process..
 *     Torna o estado PROCESS_TERMINATED.
 *     mas não destrói a estrutura DO PROCESSO.
 *     Outra rotina destruirá as informações.
 *     liberara a memória.     
 */

void exit_process ( pid_t pid, int code );


void set_caller_process_id (int pid);

int get_caller_process_id (void);

int init_process_manager (void);

FILE *get_stream_from_fd ( int pid, int fd );



// cria um novo process, uma thread e carrega a imagem.
int 
__execute_new_process ( const char *filename, 
                      char *argv[], 
                      char *envp[] );



// Pega o número da tty de um processo, dado o pid.
int process_get_tty ( int pid );

//
// End.
//

